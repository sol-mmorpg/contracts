// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;

import "@openzeppelin/contracts/token/ERC1155/IERC1155.sol";
import "@openzeppelin/contracts/utils/Counters.sol";


contract Trading {
    event TradeRequestSent(address address0, address address1, uint256 tradeId, bytes data);
    event TradeCompleted(address address0, address address1, uint256 tradeId, bytes data);
    event TradeCancelled(address canceller, uint256 tradeId);

    using Counters for Counters.Counter;
    Counters.Counter private _tradeIds;
    struct tradeData {
        bytes data; // trade data
        address address0; // sender
        address address1; // receiver
        uint256 status; // 0 for invalid, 1 for valid
    }

    IERC1155 INVENTORY;

    mapping(uint256 => tradeData) orderBook;
    mapping(address => uint256[]) tradeList;

    constructor(address _INVENTORY) {
        INVENTORY = IERC1155(_INVENTORY);
    }

    // Generate a trade by encoding it. This function merely returns a template for a trade, and does not verify it's validity
    // Validity of the trade will be checked upon acceptance
    function generateTrade(uint256[] memory askIds, uint256[] memory askQty, uint256[] memory giveIds, uint256[] memory giveQty)
        public
        pure
        returns (bytes memory data)
    {
        require(
            askIds.length == askQty.length && giveIds.length == giveQty.length,
            "Invalid trade"
        );
        return(abi.encode(askIds, askQty, giveIds, giveQty)); // Hope it doesnt give stack too deep error or I will cry

    } 
    // Decode a trade that has been generated by generateTrade()
    function parseTrade(bytes memory data)
        public
        pure
        returns(uint256[] memory askIds, uint256[] memory askQty, uint256[] memory giveIds, uint256[] memory giveQty)
        {
            return(abi.decode(data, (uint256[], uint256[], uint256[], uint256[])));
        }
    
    // Creates a trade by using trade data
    function createTrade(address recepient, bytes memory data)
        external
        returns(bool wasCreated, uint _tradeId)
    {
        uint256 tradeId = _tradeIds.current();

        tradeList[msg.sender].push(tradeId);
        tradeList[recepient].push(tradeId);

        tradeData memory newTrade = tradeData(data, msg.sender, recepient, 1);
        orderBook[tradeId] = newTrade;

        emit TradeRequestSent(msg.sender, recepient, tradeId, data);

        _tradeIds.increment();

        return(true, tradeId);
        
    }

    // Accept a trade
    function acceptTrade(uint256 tradeId)
        external
        returns(bool wasAccepted)
    {
        address address0 = orderBook[tradeId].address0;
        address address1 = orderBook[tradeId].address1;
        uint256 status = orderBook[tradeId].status;
        bytes memory data = orderBook[tradeId].data;

        require(
            address1 == msg.sender
            &&
            status == 1,
            "This trade is not for you/is no longer valid!"
        );

        (
            uint256[] memory askIds,
            uint256[] memory askQty,
            uint256[] memory giveIds,
            uint256[] memory giveQty
        ) = parseTrade(data);

        INVENTORY.safeBatchTransferFrom(address0, address1, giveIds, giveQty, "");
        INVENTORY.safeBatchTransferFrom(address1, address0, askIds, askQty, "");
        
        orderBook[tradeId].status = 0;

        emit TradeCompleted(address0, address1, tradeId, data);
        return(true);

    }

    function cancelTrade(uint256 tradeId)
        external
        returns(bool wasCancelled)
    {
        require(
            msg.sender == orderBook[tradeId].address0
            ||
            msg.sender == orderBook[tradeId].address1,
            "This trade is not for you!"
        );

        orderBook[tradeId].status = 0;
        emit TradeCancelled(msg.sender, tradeId);
        return(true);
    }
}